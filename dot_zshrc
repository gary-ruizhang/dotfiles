## prof if need, don't forget the zprof at end of file
# zmodload zsh/zprof

## Settings
setopt MENU_COMPLETE
# case-insensitive,partial-word and then substring completion
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
# set descriptions format to enable group support
zstyle ':completion:*:descriptions' format '[%d]'
# set list-colors to enable filename colorizing
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# preview directory's content with exa when completing cd
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'exa -1 --color=always $realpath'
zstyle ':fzf-tab:*' fzf-command fzf

# Enable Ctrl-x-e to edit command line
bindkey -e
autoload -U edit-command-line
zle -N edit-command-line
bindkey '^xe' edit-command-line
bindkey '^x^e' edit-command-line

# bindkey '^w' backward-kill-word
# how zsh decide a word, useful /foo/bar ctrl-w /foo
# autoload -U select-word-style
# select-word-style bash

# only work perfectly solution 
export WORDCHARS=

export EDITOR=vim
export LANG=en_US.UTF-8

export BAT_THEME="Dracula"
export MANPAGER="sh -c 'col -bx | bat -l man -p'"

# use for bash lsp. NOTE not write bash that much, this lsp maybe not useful
export GLOB_PATTERN="**/*@(.sh|.inc|.bash|.command|.zsh|zshrc|zsh_*)"

## Alias
# alias ls to exa
alias ls=exa
alias ll='ls -alF -snewest -I .DS_Store'
alias l='ls -alF -snewest -I .DS_Store'
alias awk=gawk
alias grep=rg
alias find=fd
# alias cat to bat
alias cat=bat

alias python=python3

# navi for ctrl-g
eval "$(navi widget zsh)"

# alias git to hub
eval "$(hub alias -s)"

alias chc="chezmoi cd"
alias cha="chezmoi add"
alias chd="chezmoi diff"

# bash help command for zsh
# TODO not work, (no such hash table element: run-help)
# unalias run-help
# autoload run-help
# HELPDIR=$(command brew --prefix)/share/zsh/help
# alias help=run-help

alias p=perl
alias g=git
alias gl="git log"

gm() {
  git commit -m $1
}

# workflow: git status -> git diff -> git add or checkout --
#
# r='fc -e -' repeat last command
# g status -s -> diff
#
s() {
  if [ $# -eq 0 ]
  then
    script -q /dev/null git status -s | nl | awk "{\$1=\$1};1"
  else
    git status -s | head -n$1 | awk "NR==$1 { printf \$2}" | pbcopy
  fi
}

#useful utilities for s()
alias s1='s 1'
alias s2='s 2'
alias s3='s 3'
alias s4='s 4'
alias s5='s 5'
alias s6='s 6'
alias s7='s 7'
alias s8='s 8'
alias s9='s 9'

d() {
  # FIXME not test all git status -s situation, like merge conflicts or cherry-pick
  git diff $(git status -s | head -n$1 | awk "NR==$1 { print \$2}")
}
git_add() {
  git add $(git status -s | head -n$1 | awk "NR==$1 { print \$2}")
}
git_checkout() {
  git checkout -- $(git status -s | head -n$1 | awk "NR==$1 { print \$2}")
}
#
#useful utilities for d()
alias d1='d 1'
alias d2='d 2'
alias d3='d 3'
alias d4='d 4'
alias d5='d 5'
alias d6='d 6'
alias d7='d 7'
alias d8='d 8'
alias d9='d 9'
# diff -> add
# NOTE extra space to suitable for both `dn` and `d n` operations
alias da='fc -e - d="git_add "'
# diff -> checkout --
alias dc='fc -e - d="git_checkout "'

alias c=cargo

gs() {
  local number=$1
  local len=${#number}
  local gs_temp=""
  for ((i=0; i<len; i++))
  do
    local index=${number:$i:1}
    gs_temp="${gs_temp} $(git status -s | head -n$index | awk "NR==$index { print \$2}" | tr -d '\n')"
  done
  # TODO use $gs_temp directly the string will become ':(,prefix:0)' + the real string, need to echo for transform
  git stash push $(echo $gs_temp)
}

# gcp which used when want to cherry-pick current newest commit to another branch
# alias not convient for long command
gcp() {
  local cherry=$(git show --oneline | head -1 | awk '{ print $1 }')
  echo $cherry | tr -d '\n' | pbcopy
  echo $cherry
}

alias lg=lazygit
alias k=kubectl
alias ks='kubectl -n kube-system'
alias cc='cargo clippy'
# TODO topgrade just upgrade not install new packages so brew dump file maybe no changes
alias topgrade='topgrade && brew bundle dump --force --file=~/.config/homebrew/Brewfile'
# install on new machine
# brew bundle install --file=~/.config/homebrew/Brewfile

alias vim=nvim
alias  vi=nvim
alias   v=nvim

## Tools

export ZOOKEEPER_HOME=/opt/zookeeper-3.4.12
export KAFKA_HOME=/opt/kafka_2.11-2.0.0

# HomeBrew
export PATH="/usr/local/bin:$PATH"
export PATH="/usr/local/sbin:$PATH"
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin
export PATH=$PATH:/Users/ruizhang/.local/bin
export PATH=$PATH:~/.emacs.d/bin
export PATH=$PATH:/Users/ruizhang/.config/shell-utils
# ~/.tmux/plugins
export PATH=$HOME/.tmux/plugins/t-smart-tmux-session-manager/bin:$PATH

# bigdata
export SPARK_HOME="/Users/ruizhang/bigdata/spark-3.2.1-bin-hadoop3.2"
export PATH=$PATH:$SPARK_HOME/bin
# HomeBrew END

## fnm
eval "$(fnm env)"

## fzf
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

source ~/.config/fzf-tab/fzf-tab.plugin.zsh

# slow if source but normal for new shell session
export LS_COLORS="$(vivid generate dracula)"
export FZF_DEFAULT_COMMAND="fd --type file --color=always"
export FZF_DEFAULT_OPTS='--ansi --color=fg:#f8f8f2,bg:#282a36,hl:#bd93f9 --color=fg+:#f8f8f2,bg+:#44475a,hl+:#bd93f9 --color=info:#ffb86c,prompt:#50fa7b,pointer:#ff79c6 --color=marker:#ff79c6,spinner:#ffb86c,header:#6272a4'
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_ALT_C_COMMAND="fd --type d"

## UI

# starship
eval "$(starship init zsh)"

# solve tmux term color
# export TERM=alacritty

# highlight
source /Users/ruizhang/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

fpath=(/Users/ruizhang/.zsh/zsh-completions/src $fpath)
fpath+=~/.zfunc

autoload -Uz compinit
if [ $(date +'%j') != $(stat -f '%Sm' -t '%j' ~/.zcompdump) ]; then
  compinit
else
  compinit -C
fi

source <(kubectl completion zsh)

export PATH="/usr/local/opt/binutils/bin:$PATH"

# z
eval "$(zoxide init zsh)"

source /Users/ruizhang/.config/broot/launcher/bash/br

source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh

# export JAVA_HOME=$(/usr/libexec/java_home)
export JAVA_HOME="/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home"

clear-ctrl-r() {
  zle autosuggest-clear
  # TODO clear autosuggestions before list history
  zle _atuin_search_widget
}

zle -N clear-ctrl-r

export ATUIN_NOBIND="true"
eval "$(atuin init zsh)"
bindkey '^R' clear-ctrl-r

# ignore commands for zsh-autosuggestions plugin
ZSH_AUTOSUGGEST_HISTORY_IGNORE="g stash*"

# create tmux session
# TODO hard code work path, needed change if workspace path changed
tmux_work() {
  # check if session exists, if not create one, if so attach it
  local session="work"
  tmux has-session -t $session 2>/dev/null

  if [ $? != 0 ]; then
    # Use -d to allow the rest of the function to run
    tmux new-session -d -s work -c "/Users/ruizhang/Work/workspace/ivoss_web"
    tmux rename-window npm
    # -d to prevent current window from changing
    tmux new-window -d -n front -c "/Users/ruizhang/Work/workspace/ivoss_web"
    tmux new-window -d -n back -c "/Users/ruizhang/Work/workspace/ivoss_web_service"
    tmux new-window -d -n bss/bigdata -c "/Users/ruizhang/Work/ivoss_bigdata"
    tmux new-window -d -n other -c "/Users/ruizhang"
    tmux new-window -d -n ssh -c "/Users/ruizhang"
    # -d to detach any other client (which there shouldn't be,
    # since you just created the session).
    tmux attach-session -d -t work
  else 
    tmux attach-session -t $session
  fi
}

PATH="/usr/local/opt/grep/libexec/gnubin:$PATH"

## nnn
export NNN_BMS="b:$HOME/Downloads/book/;f:$HOME/FUCK/;g:$HOME/go/;p:$HOME/python/;r:$HOME/rust/"
[ -n "$NNNLVL" ] && PS1="N$NNNLVL $PS1"
n ()
{
    # Block nesting of nnn in subshells
    [ "${NNNLVL:-0}" -eq 0 ] || {
        echo "nnn is already running"
        return
    }

    # The behaviour is set to cd on quit (nnn checks if NNN_TMPFILE is set)
    # If NNN_TMPFILE is set to a custom path, it must be exported for nnn to
    # see. To cd on quit only on ^G, remove the "export" and make sure not to
    # use a custom path, i.e. set NNN_TMPFILE *exactly* as follows:
    #      NNN_TMPFILE="${XDG_CONFIG_HOME:-$HOME/.config}/nnn/.lastd"
    export NNN_TMPFILE="${XDG_CONFIG_HOME:-$HOME/.config}/nnn/.lastd"

    # Unmask ^Q (, ^V etc.) (if required, see `stty -a`) to Quit nnn
    # stty start undef
    # stty stop undef
    # stty lwrap undef
    # stty lnext undef

    # The command builtin allows one to alias nnn to n, if desired, without
    # making an infinitely recursive alias
    command nnn -d "$@"

    [ ! -f "$NNN_TMPFILE" ] || {
        . "$NNN_TMPFILE"
        rm -f "$NNN_TMPFILE" > /dev/null
    }
}

# remove duplicate in $PATH
typeset -U path

##
# zprof
